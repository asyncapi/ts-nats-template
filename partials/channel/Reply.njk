
{% macro reply(channelName, parameters, subscribtionMessage, publishMessage, server) %}
export function reply(
  onRequest: (err?: NatsError, msg?: {{subscribtionMessage.uid() | pascalCase}}Message{% if parameters | length %}, {{parameters | realizeParametersForChannel(false)}}{% endif %}) => {{publishMessage.uid() | pascalCase}}Message, 
  onReplyError: (err: NatsError) => void,
  nc: Client,
  {% if parameters | length %}
    {{parameters | realizeParametersForChannel}}
  {% endif %}
  ): Promise<Subscription> {
  return new Promise(async (resolve, reject) => {
    if (nc) {
      try {
        let subscribeOptions: SubscriptionOptions = {};
        {%- if subscribtionMessage | hasNatsBindings %}
        {%- if subscribtionMessage.bindings().nats().queue() | length %}
        //If queue
        subscribeOptions.queue = '{{subscribtionMessage.bindings().nats().queue().name()}}';
        {%- endif %}
        {%- if subscribtionMessage.bindings().nats().unsubAfter() | length %}
        //If unsubafter
        subscribeOptions.max = {{subscribtionMessage.bindings().nats().unsubAfter()}};
        {%- endif %}
        {%- endif %}

        let subscription = nc.subscribe({{parameters | realizeChannelName(channelName)}}, (err, msg) => {
          if (err) {
            onRequest(err);
          } else {
            {%- if parameters | length %}
            const unmodifiedChannel = {{channelName | realizeChannelNameWithoutParameters}}
            const receivedTopicParameters = {
              {%- set counter = 1 %}
              {%- for parameterName, parameter in parameters %}
                {{parameterName}} : msg.subject.slice(unmodifiedChannel.split("${{'{'+ parameterName+ '}'}}")[0].length, msg.subject.length-unmodifiedChannel.split("${{'{'+parameterName+'}'}}")[1].length){%- if counter < (parameters | length) %},{%- endif %}
                {%- set counter = counter+1 %}
              {%- endfor %}
            }
            {%- endif %}
            let receivedDataHooks = Hooks.getInstance().getRecievedDataHook();
            var processedDataReceived : any = msg.data;
            for(let hook of receivedDataHooks){
              processedDataReceived = hook(processedDataReceived);
            }
            let requestData = {{subscribtionMessage.name() | pascalCase}}Message.toMessage(processedDataReceived);

            let responseObject = onRequest(undefined, requestData{% if parameters | length %},
              {%- set counter = 1 %}
              {%- for parameterName, parameter in parameters %}
                receivedTopicParameters['{{parameterName}}']{%- if counter < (parameters | length) %},{%- endif %}
                {%- set counter = counter+1 %}
              {%- endfor %}
              {%- endif %});
            if (msg.reply) {
              try {
                let publishDataHooks = Hooks.getInstance().getBeforeSendingDataHook();
                var dataToPublish : any = responseObject;
                for(let hook of publishDataHooks){
                  dataToPublish = hook(dataToPublish);
                }
                nc.publish(msg.reply, dataToPublish);
              } catch (e) {
                if (onReplyError) {
                  onReplyError(e)
                } else {
                  console.error(e)
                }
              }
            } else {
              let error = new NatsError('Expected request to need a reply, did not..', '000');
              if (onReplyError) {
                onReplyError(error)
              } else {
                console.error(error)
              }
            }
          }
        }, subscribeOptions);
        resolve(subscription);
      } catch (e) {
        reject(e);
      }
    } else {
      reject(new Error("Nats client is not connected"));
    }
  })
}

{% endmacro %}
