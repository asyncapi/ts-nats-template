
{%- from "./OnSendingData.njk" import OnSendingData %}
{%- from "./OnReceivingData.njk" import OnReceivingData %}
{%- from "./ChannelParameterUnwrap.njk" import unwrap %}
{% macro reply(channelName, channelParameters, replyMessage, receiveMessage, server, params, defaultContentType) %}
export function reply(
    onRequest: (err?: NatsTypescriptTemplateError, msg?: {{receiveMessage | getMessageType}}{% if channelParameters | length %}, {{channelParameters | realizeParametersForChannel(false)}}{% endif %}) => 
    {%- if params.promisifyReplyCallback | length %}Promise<{%- endif %}{{replyMessage | getMessageType}}{%-if params.promisifyReplyCallback | length %}>{%- endif %}, 
    onReplyError: (err: NatsTypescriptTemplateError) => void,
    nc: Client
    {% if channelParameters | length %}
      ,{{channelParameters | realizeParametersForChannel}}
    {% endif %},
    options?: SubscriptionOptions
  ): Promise<Subscription> {
  return new Promise(async (resolve, reject) => {
    try {
      let subscribeOptions: SubscriptionOptions = {... options};
      {%- if receiveMessage | hasNatsBindings %}
      {%- if receiveMessage.bindings().nats().queue() | length %}
      //If queue
      subscribeOptions.queue = '{{receiveMessage.bindings().nats().queue()}}';
      {%- endif %}
      {%- if receiveMessage.bindings().nats().unsubAfter() | length %}
      //If unsubafter
      subscribeOptions.max = {{receiveMessage.bindings().nats().unsubAfter()}};
      {%- endif %}
      {%- endif %}

      let subscription = await nc.subscribe({{channelParameters | realizeChannelName(channelName)}}, {%- if params.promisifyReplyCallback | length %}async{%- endif %} (err, msg) => {
        if (err) {
          onRequest(err);
        } else {
          {%- if channelParameters | length %}
          {{unwrap(channelName, channelParameters)}}
          {%- endif %}
          
          {%- if receiveMessage.payload() | messageHasNotNullPayload %}
          try{
            {{OnReceivingData(receiveMessage, defaultContentType)}}
          }catch(e){
            onReplyError(e)
            return;
          }
          let message = {%-if params.promisifyReplyCallback | length %}await{%- endif %} onRequest(undefined, receivedData{% if channelParameters | length %},
            {%- set counter = 1 %}
            {%- for parameterName, parameter in channelParameters %}
              {{parameterName | camelCase}}Param{%- if counter < (channelParameters | length) %},{%- endif %}
              {%- set counter = counter+1 %}
            {%- endfor %}
            {%- endif %});
          {%- else %}
          let message = {%-if params.promisifyReplyCallback | length %}await{%- endif %} onRequest(undefined, null{% if channelParameters | length %},
            {%- set counter = 1 %}
            {%- for parameterName, parameter in channelParameters %}
              {{parameterName | camelCase}}Param{%- if counter < (channelParameters | length) %},{%- endif %}
              {%- set counter = counter+1 %}
            {%- endfor %}
            {%- endif %});
          {%- endif %}
          
          if (msg.reply) {
            {%- if replyMessage.payload() | messageHasNotNullPayload %}
            try{
              {{OnSendingData(replyMessage, defaultContentType)}}
            }catch(e){
              onReplyError(e)
              return;
            }
            
            await nc.publish(msg.reply, dataToSend);
            {%- else %}
            await nc.publish(msg.reply, null);
            {%- endif %}
          } else {
            let error = new NatsTypescriptTemplateError('Expected request to need a reply, did not..', '000');
            onReplyError(error)
            return;
          }
        }
      }, subscribeOptions);
      resolve(subscription);
    } catch (e) {
      reject(NatsTypescriptTemplateError.errorForCode(ErrorCode.INTERNAL_NATS_TS_ERROR, e));
    }
  })
}

{% endmacro %}
