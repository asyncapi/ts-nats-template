
{% macro reply(channelName, channelParameters, subscribtionMessage, publishMessage, server, params) %}
export function reply(
  onRequest: (err?: NatsTypescriptTemplateError, msg?: {{publishMessage.uid() | pascalCase}}Message{% if channelParameters | length %}, {{channelParameters | realizeParametersForChannel(false)}}{% endif %}) => 
  {%- if params.promisifyReplyCallback | length %}Promise<{%- endif %}{{subscribtionMessage.uid() | pascalCase}}Message{%-if params.promisifyReplyCallback | length %}>{%- endif %}, 
  onReplyError: (err: NatsTypescriptTemplateError) => void,
  nc: Client,
  {% if channelParameters | length %}
    {{channelParameters | realizeParametersForChannel}}
  {% endif %}
  ): Promise<Subscription> {
  return new Promise(async (resolve, reject) => {
    try {
      let subscribeOptions: SubscriptionOptions = {};
      {%- if publishMessage | hasNatsBindings %}
      {%- if publishMessage.bindings().nats().queue() | length %}
      //If queue
      subscribeOptions.queue = '{{publishMessage.bindings().nats().queue().name()}}';
      {%- endif %}
      {%- if publishMessage.bindings().nats().unsubAfter() | length %}
      //If unsubafter
      subscribeOptions.max = {{publishMessage.bindings().nats().unsubAfter()}};
      {%- endif %}
      {%- endif %}

      let subscription = nc.subscribe({{channelParameters | realizeChannelName(channelName)}}, {%- if params.promisifyReplyCallback | length %}async{%- endif %} (err, msg) => {
        if (err) {
          onRequest(err);
        } else {
          {%- if channelParameters | length %}
          const unmodifiedChannel = {{channelName | realizeChannelNameWithoutParameters}}
          const receivedTopicParameters = {
            {%- set counter = 1 %}
            {%- for parameterName, parameter in channelParameters %}
              {{parameterName}} : msg.subject.slice(unmodifiedChannel.split("{{'{'+ parameterName+ '}'}}")[0].length, msg.subject.length-unmodifiedChannel.split("{{'{'+parameterName+'}'}}")[1].length){%- if counter < (channelParameters | length) %},{%- endif %}
              {%- set counter = counter+1 %}
            {%- endfor %}
          }
          {%- endif %}
          try {
            let receivedDataHooks = Hooks.getInstance().getRecievedDataHook();
            var processedDataReceived : any = msg.data;
            for(let hook of receivedDataHooks){
              processedDataReceived = hook(processedDataReceived);
            }
          } catch (e) {
            onReplyError(NatsTypescriptTemplateError.errorForCode(ErrorCode.HOOK_ERROR, e))
            return;
          }
          let requestData = {{publishMessage.name() | pascalCase}}Message.toMessage(processedDataReceived);
          let responseObject = {%-if params.promisifyReplyCallback | length %}await{%- endif %} onRequest(undefined, requestData{% if channelParameters | length %},
            {%- set counter = 1 %}
            {%- for parameterName, parameter in channelParameters %}
              receivedTopicParameters['{{parameterName}}']{%- if counter < (channelParameters | length) %},{%- endif %}
              {%- set counter = counter+1 %}
            {%- endfor %}
            {%- endif %});
          if (msg.reply) {
            try {
              let publishDataHooks = Hooks.getInstance().getBeforeSendingDataHook();
              var dataToPublish : any = responseObject;
              for(let hook of publishDataHooks){
                dataToPublish = hook(dataToPublish);
              }
              nc.publish(msg.reply, dataToPublish);
            } catch (e) {
              onReplyError(NatsTypescriptTemplateError.errorForCode(ErrorCode.HOOK_ERROR, e))
            }
          } else {
            let error = new NatsTypescriptTemplateError('Expected request to need a reply, did not..', '000');
            onReplyError(error)
          }
        }
      }, subscribeOptions);
      resolve(subscription);
    } catch (e) {
      reject(NatsTypescriptTemplateError.errorForCode(ErrorCode.INTERNAL_NATS_TS_ERROR, e));
    }
  })
}

{% endmacro %}
