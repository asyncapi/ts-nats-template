
{% macro subscribe(channelName, parameters, subscribtionMessage, server) %}
export function subscribe(
  onDataCallback : (err?: NatsError, msg?: {{subscribtionMessage.uid() | pascalCase}}Message) => void, 
  nc: Client,
  {% if parameters | length %}
    {{parameters | realizeParametersForChannel}}
  {% endif %}
  ): Promise<Subscription> {
  return new Promise(async (resolve, reject) => {
    try{
      let subscribeOptions: SubscriptionOptions = {};
      {%- if subscribtionMessage | hasNatsBindings %}
      {%- if subscribtionMessage.bindings().nats().queue() | length %}
      //If queue
      subscribeOptions.queue = '{{subscribtionMessage.bindings().nats().queue().name()}}';
      {%- endif %}
      {%- if subscribtionMessage.bindings().nats().unsubAfter() | length %}
      //If unsubafter
      subscribeOptions.max = {{subscribtionMessage.bindings().nats().unsubAfter()}};
      {%- endif %}
      {%- endif %}

      let subscription = nc.subscribe({{parameters | realizeChannelName(channelName)}}, (err, msg) => {
        if(err){
          onDataCallback(err);
        }else{
          
          let receivedDataHooks = Hooks.getRecievedDataHook();
          var processedDataReceived: any = msg.data;
          for(let hook of receivedDataHooks){
            processedDataReceived = hook(processedDataReceived);
          }
          let publishedData = {{subscribtionMessage.name() | pascalCase}}Message.toMessage(processedDataReceived);

          onDataCallback(undefined, publishedData);
        }
      }, subscribeOptions);
      resolve(subscription);
    }catch(e){
      reject(e);
    }
  })
}

{% endmacro %}
