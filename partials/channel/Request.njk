
{% macro request(channelName, channelParameters, publishMessage, subscribtionMessage, server) %}
export function request(
  requestMessage: {{subscribtionMessage.uid() | pascalCase}}Message.{{subscribtionMessage.uid() | pascalCase}},
  nc: Client,
  {% if channelParameters | length %}
    {{channelParameters | realizeParametersForChannel}}
  {% endif %}
  ): Promise<{{publishMessage.uid() | pascalCase}}Message.{{publishMessage.uid() | pascalCase}}> {
  return new Promise(async (resolve, reject) => {
    try {
      let publishDataHooks = Hooks.getInstance().getBeforeSendingDataHook();
      var requestData : any = requestMessage;
      for(let hook of publishDataHooks){
        requestData = hook(requestData);
      }
    }catch(e){
      reject(NatsTypescriptTemplateError.errorForCode(ErrorCode.HOOK_ERROR, e));
      return;
    }
    let msg;
    try {
      msg = await nc.request({{channelParameters | realizeChannelName(channelName)}}, undefined, requestData)
    }catch(e){
      reject(NatsTypescriptTemplateError.errorForCode(ErrorCode.INTERNAL_NATS_TS_ERROR, e));
      return;
    }
    try{
      let receivedDataHooks = Hooks.getInstance().getRecievedDataHook();
      var processedDataReceived: any = msg.data;
      for(let hook of receivedDataHooks){
        processedDataReceived = hook(processedDataReceived);
      }
      let publishedData = {{publishMessage.name() | pascalCase}}Message.Convert.to{{publishMessage.name() | pascalCase}}(processedDataReceived);
      resolve(publishedData);
    }catch(e){
      reject(NatsTypescriptTemplateError.errorForCode(ErrorCode.HOOK_ERROR, e));
    }
  })
}

{% endmacro %}
