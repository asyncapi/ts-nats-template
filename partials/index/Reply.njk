
{% macro reply(defaultContentType, channelName, subscribeMessage, publishMessage, messageDescription, parameters) %}
  /**
  *  {{messageDescription}}
  * @param onRequest Called when request recieved.
  * @param onReplyError Called when it was not possible to send the reply.
  */
  public replyTo{{channelName | pascalCase }}(onRequest : (err?: NatsError, msg?: {{ subscribeMessage.uid() | pascalCase }}Message{% if parameters | length %}, {{parameters | realizeParametersForChannel(false)}}{% endif %}) => {{ publishMessage.uid() | pascalCase }}Message, onReplyError : (err: NatsError) => void 
  {% if parameters | length %}
    ,{{parameters | realizeParametersForChannel}}
  {% endif %}): Promise<Subscription> {
    {%- if subscribeMessage.contentType() | isBinaryPayload(defaultContentType) %}
    const nc: Client = this.binaryClient!;
    {%- endif %}
    {%- if subscribeMessage.contentType() | isStringPayload(defaultContentType) %}
    const nc: Client = this.stringClient!;
    {%- endif %}
    {%- if subscribeMessage.contentType() | isJsonPayload(defaultContentType) %}
    const nc: Client = this.jsonClient!;
    {%- endif %}
    
    if(nc){
      return {{ channelName | camelCase }}Channel.reply(onRequest, onReplyError, nc
      {% if parameters | length %}
        ,{{parameters | realizeParametersForChannelWithoutType}}
      {% endif %});
    }else{
      return Promise.reject(new Error('Nats client is not connected, could not send message on channel {{ channelName | camelCase }}'))
    }
  }
{% endmacro %}
