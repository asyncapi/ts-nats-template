
{% macro standard(asyncapi) %}

  public jsonClient?: Client;
  public stringClient?: Client;
  public binaryClient?: Client;
  public options?: NatsConnectionOptions;

	/**
	 *
	 * @param options options to use, payload is omitted if sat in the AsyncAPI document.
	 */
  constructor() {
    super();
  }
  /**
   * Try to connect to the NATS server with the different payloads.
   */
  connect(options : NatsConnectionOptions): Promise<void>{
    return new Promise(async (resolve: () => void, reject: (error: any) => void) => {
      this.options = this.setDefaultOptions(options);
      try{
        {%- if asyncapi | containsBinaryPayload %}
        this.options.payload = Payload.BINARY;
        this.binaryClient = await connect(this.options);
        this.chainEvents(this.binaryClient);
        {%- endif %}
        {%- if asyncapi | containsStringPayload %}
        this.options.payload = Payload.STRING;
        this.stringClient = await connect(this.options);
        this.chainEvents(this.stringClient);
        {%- endif %}
        {%- if asyncapi | containsJsonPayload %}
        this.options.payload = Payload.JSON;
        this.jsonClient = await connect(this.options);
        this.chainEvents(this.jsonClient);
        {%- endif %}
        resolve();
      }catch(e){
        reject(NatsTypescriptTemplateError.errorForCode(ErrorCode.INTERNAL_NATS_TS_ERROR, e));
      }
    })
  }


  /**
   * Disconnect all clients from the server
   */
  async disconnect(){
    {%- if asyncapi | containsBinaryPayload %}
    this.binaryClient!.close()
    {%- endif %}
    {%- if asyncapi | containsStringPayload %}
    this.stringClient!.close()
    {%- endif %}
    {%- if asyncapi | containsJsonPayload %}
    this.jsonClient!.close()
    {%- endif %}
  }
  
  private chainEvents(ns: Client){
      ns.on('permissionError', (e: NatsError) => {
        this.emit(AvailableEvents.permissionError, NatsTypescriptTemplateError.errorForCode(ErrorCode.INTERNAL_NATS_TS_ERROR, e))
      });
      ns.on('close', (e: NatsError) => {
        this.emit(AvailableEvents.close, NatsTypescriptTemplateError.errorForCode(ErrorCode.INTERNAL_NATS_TS_ERROR, e))
      });
      ns.on('connect', (connection: Client, serverURL: string, info: ServerInfo) => {
        this.emit(AvailableEvents.connect, connection, serverURL, info)
      });
      ns.on('connecting', (serverURL: string) => {
        this.emit(AvailableEvents.connecting, serverURL)
      });
      ns.on('disconnect', (serverURL: string) => {
        this.emit(AvailableEvents.disconnect, serverURL)
      });
      ns.on('error', (e: NatsError) => {
        this.emit(AvailableEvents.error, NatsTypescriptTemplateError.errorForCode(ErrorCode.INTERNAL_NATS_TS_ERROR, e))
      });
      ns.on('pingcount', () => {
        this.emit(AvailableEvents.pingcount)
      });
      ns.on('pingtimer', () => {
        this.emit(AvailableEvents.pingtimer)
      });
      ns.on('reconnect', (connection: Client, serverURL: string, info: ServerInfo) => {
        this.emit(AvailableEvents.reconnect, connection, serverURL, info)
      });
      ns.on('reconnecting', (serverURL: string) => {
        this.emit(AvailableEvents.reconnecting, serverURL)
      });
      ns.on('serversChanged', (e: ServersChangedEvent) => {
        this.emit(AvailableEvents.serversChanged, e)
      });
      ns.on('subscribe', (e: SubEvent) => {
        this.emit(AvailableEvents.subscribe, e)
      });
      ns.on('unsubscribe', (e: SubEvent) => {
        this.emit(AvailableEvents.unsubscribe, e)
      });
      ns.on('yield', () => {
        this.emit(AvailableEvents.yield)
      });
  }
  
  /**
   * Try to connect to the NATS server with user credentials
   */
  async connectWithUserCreds(userCreds: string, options?: NatsConnectionOptions){
    if(!options){
      options = {
        userCreds: userCreds
      };
    }else{
      options.userCreds = userCreds;
    }
    await this.connect(options);
  }
  /**
   * Try to connect to the NATS server with user and password
   */
  async connectWithUserPass(user: string, pass: string, options?: NatsConnectionOptions){
    if(!options){
      options = {
        user: user,
        pass: pass
      };
    }else{
      options.user = user;
      options.pass = pass;
    }
    await this.connect(options);
  }
  
  /**
   * Try to connect to the NATS server which has no authentication
   */
  async connectToHost(host: string, options?: NatsConnectionOptions){
    if(!options){
      options = {
        servers: [host]
      };
    }else{
      options.servers = [host];
    }
    await this.connect(options);
  }

  /**
   * Try to connect to the NATS server with nkey authentication
   */
  async connectWithNkey(publicNkey: string, seed: string, options?: NatsConnectionOptions){
    if(!options){
      options = {
        nkey: publicNkey,
        nonceSigner: (nonce: string): Buffer => {
          const sk = fromSeed(Buffer.from(seed));
          return sk.sign(Buffer.from(nonce));
        }
      };
    }else{
      options.nkey = publicNkey;
      options.nonceSigner = (nonce: string): Buffer => {
        const sk = fromSeed(Buffer.from(seed));
        return sk.sign(Buffer.from(nonce));
      }
    }
    await this.connect(options);
  }

  /**
   * Set the default options based on the AsyncAPI file.
   * @param options to set
   */
  private setDefaultOptions(options: NatsConnectionOptions){
    //If server binding options sat set the options
    options.encoding = 'utf8';
    return options;
  }
{% endmacro %}